# 数组

数组是以'['起始以']'结束的复合类型 -- 数组元素可以为任意JSON类型，包括
数组类型.

数组与字符串相似的一点是，无法提前确定数组的长度，因此我们同样需要
动态管理内存，可以也用stack作为内存buffer.
相比字符串动态存储字节，数组的单位是`lept_value`，即JSON数值类型.

`C`语言内存管理相比`C++`更为复杂，我们需要自己`free()`掉申请的内存空间，
防止内存泄露.

这里数组用传统方式实现，而不是用链表. 每个数组元素是一个指向JSON数值的
指针`lept_value *`和一个表示数组大小的计数器`size`.

## 具体内存分配过程

每次解析一个数值，`push`进`stack`中. 解析完毕后将整个内存空间复制出来，
并将数组的指针执行复制后的新创建的内存空间.

# 练习题

## 处理空白

最简单粗暴的方式是在每次预期访问字符时调用`lept_parse_whitespace`跳过可能的所用空格.
(这样做相比作者会多调用一次)

## 释放内存

在数组的解析过程中调用了`malloc`, 

* 对于解析成功，通过最后的`lept_free`函数释放申请的内存. 由于数组是一个复合结构,
我们把数组内的元素通过递归调用`lept_free()`释放元素对应申请的内存，最后释放
自身`v->u.a.e`.

* 对于解析失败，需要逐个把`stack`中的元素通过`lept_free()`释放内存.
解析失败时`LEPT_STRING`类型并步需要额外进行`lept_free`的操作, 因为在
`STRING`的解析过程中只是在`stack`中申请内存，只要将`stack`的`top`指针
重置即可. 在解析`lept_parse`的最后通过`free(c.stack)`释放栈中的内存.

